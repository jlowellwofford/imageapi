// Code generated by go-swagger; DO NOT EDIT.

package restapi

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"encoding/json"
)

var (
	// SwaggerJSON embedded version of the swagger document used at generation time
	SwaggerJSON json.RawMessage
	// FlatSwaggerJSON embedded flattened version of the swagger document used at generation time
	FlatSwaggerJSON json.RawMessage
)

func init() {
	SwaggerJSON = json.RawMessage([]byte(`{
  "consumes": [
    "application/json"
  ],
  "produces": [
    "application/json"
  ],
  "schemes": [
    "http",
    "https"
  ],
  "swagger": "2.0",
  "info": {
    "description": "This API specification describes a service for attaching, mounting and preparing container images and manipulating those containers.\n\nIn general, higher level objects can either reference lower level objects (e.g. a mount referencing an attachment point) by a reference ID, \nor, they can contain the full specification of those lower objects.\n\nIf an object references another by ID, deletion of that object does not effect the underlying object.\n\nIf an object defines a lower level object, that lower level object will automatically be deleted on deletion of the higher level object.\n\nFor instance, if a container contains all of the defintions for all mount points and attachments, deletion of the container will automatically unmount\nand detach those lower objects.\n",
    "title": "Image API",
    "version": "1.0.0"
  },
  "basePath": "/imageapi/v1",
  "paths": {
    "/attach/rbd": {
      "get": {
        "tags": [
          "attach"
        ],
        "operationId": "list_rbds",
        "responses": {
          "200": {
            "description": "list of rbd maps",
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/definitions/rbd"
              }
            }
          },
          "default": {
            "description": "generic error response",
            "schema": {
              "$ref": "#/definitions/error"
            }
          }
        }
      },
      "post": {
        "tags": [
          "attach"
        ],
        "operationId": "map_rbd",
        "parameters": [
          {
            "name": "rbd",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/rbd"
            }
          }
        ],
        "responses": {
          "201": {
            "description": "RBD attach succeed",
            "schema": {
              "$ref": "#/definitions/rbd"
            }
          },
          "default": {
            "description": "error",
            "schema": {
              "$ref": "#/definitions/error"
            }
          }
        }
      }
    },
    "/attach/rbd/{id}": {
      "get": {
        "tags": [
          "attach"
        ],
        "operationId": "get_rbd",
        "responses": {
          "200": {
            "description": "RBD entry",
            "schema": {
              "$ref": "#/definitions/rbd"
            }
          },
          "default": {
            "description": "error",
            "schema": {
              "$ref": "#/definitions/error"
            }
          }
        }
      },
      "delete": {
        "tags": [
          "attach"
        ],
        "operationId": "unmap_rbd",
        "responses": {
          "200": {
            "description": "Unmapped",
            "schema": {
              "$ref": "#/definitions/rbd"
            }
          },
          "default": {
            "description": "error",
            "schema": {
              "$ref": "#/definitions/error"
            }
          }
        }
      },
      "parameters": [
        {
          "type": "integer",
          "format": "int64",
          "name": "id",
          "in": "path",
          "required": true
        }
      ]
    },
    "/container": {
      "get": {
        "description": "Get a list of containers",
        "tags": [
          "containers"
        ],
        "operationId": "list_containers",
        "responses": {
          "200": {
            "description": "List of containers",
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/definitions/container"
              }
            }
          },
          "default": {
            "description": "error",
            "schema": {
              "$ref": "#/definitions/error"
            }
          }
        }
      },
      "post": {
        "description": "Create a container",
        "tags": [
          "containers"
        ],
        "operationId": "create_container",
        "parameters": [
          {
            "name": "container",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/container"
            }
          }
        ],
        "responses": {
          "201": {
            "description": "Container creation succeed",
            "schema": {
              "$ref": "#/definitions/container"
            }
          },
          "default": {
            "description": "error",
            "schema": {
              "$ref": "#/definitions/error"
            }
          }
        }
      }
    },
    "/container/byname/{name}": {
      "get": {
        "description": "Get a container definition",
        "tags": [
          "containers"
        ],
        "operationId": "get_container_byname",
        "responses": {
          "200": {
            "description": "Container entry",
            "schema": {
              "$ref": "#/definitions/container"
            }
          },
          "default": {
            "description": "error",
            "schema": {
              "$ref": "#/definitions/error"
            }
          }
        }
      },
      "delete": {
        "description": "Delete a container defition.  \nThis will stop running containers.\n",
        "tags": [
          "containers"
        ],
        "operationId": "delete_container_byname",
        "responses": {
          "200": {
            "description": "Container deleted",
            "schema": {
              "$ref": "#/definitions/container"
            }
          },
          "default": {
            "description": "error",
            "schema": {
              "$ref": "#/definitions/error"
            }
          }
        }
      },
      "parameters": [
        {
          "pattern": "^[a-zA-Z0-9._-]*$",
          "type": "string",
          "name": "name",
          "in": "path",
          "required": true
        }
      ]
    },
    "/container/byname/{name}/{state}": {
      "get": {
        "description": "Request a (valid) state for a container. \nValid states to request include: ` + "`" + `running` + "`" + `, ` + "`" + `exited` + "`" + `, ` + "`" + `paused` + "`" + ` (paused is not yet implemented)\n",
        "tags": [
          "containers"
        ],
        "operationId": "set_container_state_byname",
        "responses": {
          "200": {
            "description": "Container state changed",
            "schema": {
              "$ref": "#/definitions/container"
            }
          },
          "default": {
            "description": "error",
            "schema": {
              "$ref": "#/definitions/error"
            }
          }
        }
      },
      "parameters": [
        {
          "pattern": "^[a-zA-Z0-9._-]*$",
          "type": "string",
          "name": "name",
          "in": "path",
          "required": true
        },
        {
          "enum": [
            "running",
            "exited"
          ],
          "type": "string",
          "name": "state",
          "in": "path",
          "required": true
        }
      ]
    },
    "/container/{id}": {
      "get": {
        "description": "Get a container definition",
        "tags": [
          "containers"
        ],
        "operationId": "get_container",
        "responses": {
          "200": {
            "description": "Container entry",
            "schema": {
              "$ref": "#/definitions/container"
            }
          },
          "default": {
            "description": "error",
            "schema": {
              "$ref": "#/definitions/error"
            }
          }
        }
      },
      "delete": {
        "description": "Delete a container defition.  \nThis will stop running containers.\n",
        "tags": [
          "containers"
        ],
        "operationId": "delete_container",
        "responses": {
          "200": {
            "description": "Container deleted",
            "schema": {
              "$ref": "#/definitions/container"
            }
          },
          "default": {
            "description": "error",
            "schema": {
              "$ref": "#/definitions/error"
            }
          }
        }
      },
      "parameters": [
        {
          "type": "integer",
          "format": "int64",
          "name": "id",
          "in": "path",
          "required": true
        }
      ]
    },
    "/container/{id}/{state}": {
      "get": {
        "description": "Request a (valid) state for a container. \nValid states to request include: ` + "`" + `running` + "`" + `, ` + "`" + `exited` + "`" + `, ` + "`" + `paused` + "`" + ` (paused is not yet implemented)\n",
        "tags": [
          "containers"
        ],
        "operationId": "set_container_state",
        "responses": {
          "200": {
            "description": "Container state changed",
            "schema": {
              "$ref": "#/definitions/container"
            }
          },
          "default": {
            "description": "error",
            "schema": {
              "$ref": "#/definitions/error"
            }
          }
        }
      },
      "parameters": [
        {
          "type": "integer",
          "format": "int64",
          "name": "id",
          "in": "path",
          "required": true
        },
        {
          "enum": [
            "running",
            "exited"
          ],
          "type": "string",
          "name": "state",
          "in": "path",
          "required": true
        }
      ]
    },
    "/mount": {
      "get": {
        "description": "List mounts",
        "tags": [
          "mounts"
        ],
        "operationId": "list_mounts",
        "responses": {
          "200": {
            "description": "list all mounts",
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/definitions/mount"
              }
            }
          },
          "default": {
            "description": "error",
            "schema": {
              "$ref": "#/definitions/error"
            }
          }
        }
      },
      "post": {
        "description": "Create a new mount by mount specification.",
        "tags": [
          "mounts"
        ],
        "operationId": "mount",
        "parameters": [
          {
            "name": "mount",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/mount"
            }
          }
        ],
        "responses": {
          "201": {
            "description": "mount succeed",
            "schema": {
              "$ref": "#/definitions/mount"
            }
          },
          "default": {
            "description": "error",
            "schema": {
              "$ref": "#/definitions/error"
            }
          }
        }
      },
      "delete": {
        "description": "Unmount a specified mount.  Note that mount reference IDs must be specified.",
        "tags": [
          "mounts"
        ],
        "parameters": [
          {
            "name": "mount",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/mount"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Unmount succeeded",
            "schema": {
              "$ref": "#/definitions/mount"
            }
          },
          "default": {
            "description": "Unmount failed",
            "schema": {
              "$ref": "#/definitions/error"
            }
          }
        }
      }
    },
    "/mount/overlay": {
      "get": {
        "tags": [
          "mounts"
        ],
        "operationId": "list_mounts_overlay",
        "responses": {
          "200": {
            "description": "list of overlay mounts",
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/definitions/mount_overlay"
              }
            }
          },
          "default": {
            "description": "error",
            "schema": {
              "$ref": "#/definitions/error"
            }
          }
        }
      },
      "post": {
        "tags": [
          "mounts"
        ],
        "operationId": "mount_overlay",
        "parameters": [
          {
            "name": "mount",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/mount_overlay"
            }
          }
        ],
        "responses": {
          "201": {
            "description": "Overlay mount succeed",
            "schema": {
              "$ref": "#/definitions/mount_overlay"
            }
          },
          "default": {
            "description": "error",
            "schema": {
              "$ref": "#/definitions/error"
            }
          }
        }
      }
    },
    "/mount/overlay/{id}": {
      "get": {
        "tags": [
          "mounts"
        ],
        "operationId": "get_mount_overlay",
        "responses": {
          "200": {
            "description": "Overlay mount entry",
            "schema": {
              "$ref": "#/definitions/mount_overlay"
            }
          },
          "default": {
            "description": "error",
            "schema": {
              "$ref": "#/definitions/error"
            }
          }
        }
      },
      "delete": {
        "tags": [
          "mounts"
        ],
        "operationId": "unmount_overlay",
        "responses": {
          "200": {
            "description": "Unmounted",
            "schema": {
              "$ref": "#/definitions/mount_overlay"
            }
          },
          "default": {
            "description": "error",
            "schema": {
              "$ref": "#/definitions/error"
            }
          }
        }
      },
      "parameters": [
        {
          "type": "integer",
          "format": "int64",
          "name": "id",
          "in": "path",
          "required": true
        }
      ]
    },
    "/mount/rbd": {
      "get": {
        "tags": [
          "mounts"
        ],
        "operationId": "list_mounts_rbd",
        "responses": {
          "200": {
            "description": "list of rbd mounts",
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/definitions/mount_rbd"
              }
            }
          },
          "default": {
            "description": "error",
            "schema": {
              "$ref": "#/definitions/error"
            }
          }
        }
      },
      "post": {
        "tags": [
          "mounts"
        ],
        "operationId": "mount_rbd",
        "parameters": [
          {
            "name": "mount",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/mount_rbd"
            }
          }
        ],
        "responses": {
          "201": {
            "description": "RBD mount succeed",
            "schema": {
              "$ref": "#/definitions/mount_rbd"
            }
          },
          "default": {
            "description": "error",
            "schema": {
              "$ref": "#/definitions/error"
            }
          }
        }
      }
    },
    "/mount/rbd/{id}": {
      "get": {
        "tags": [
          "mounts"
        ],
        "operationId": "get_mount_rbd",
        "responses": {
          "200": {
            "description": "RBD mount entry",
            "schema": {
              "$ref": "#/definitions/mount_rbd"
            }
          },
          "default": {
            "description": "error",
            "schema": {
              "$ref": "#/definitions/error"
            }
          }
        }
      },
      "delete": {
        "tags": [
          "mounts"
        ],
        "operationId": "unmount_rbd",
        "responses": {
          "200": {
            "description": "Unmounted",
            "schema": {
              "$ref": "#/definitions/mount_rbd"
            }
          },
          "default": {
            "description": "error",
            "schema": {
              "$ref": "#/definitions/error"
            }
          }
        }
      },
      "parameters": [
        {
          "type": "integer",
          "format": "int64",
          "name": "id",
          "in": "path",
          "required": true
        }
      ]
    }
  },
  "definitions": {
    "container": {
      "description": "The ` + "`" + `container` + "`" + ` option describes a minimally namespaced container.\n\nA container is identified by a service-provided unique numeric ` + "`" + `pid` + "`" + `.\n\nOptionally, a container can be provided with a ` + "`" + `name` + "`" + `.  The name must\nbe unique.  Containers can be referenced by ` + "`" + `name` + "`" + ` if provided.\n",
      "type": "object",
      "required": [
        "mount",
        "command"
      ],
      "properties": {
        "command": {
          "type": "string"
        },
        "id": {
          "$ref": "#/definitions/id"
        },
        "logfile": {
          "type": "string",
          "readOnly": true
        },
        "mount": {
          "$ref": "#/definitions/mount"
        },
        "name": {
          "description": "name is an optional identifier for the container.  Name must be unique.",
          "$ref": "#/definitions/name"
        },
        "namespaces": {
          "description": "A list of Linux namespaces to use.\n\nNote: This is currently unused.  All containers currently get ` + "`" + `mnt` + "`" + ` and ` + "`" + `pid` + "`" + `.\n      It's here as a placeholder for future use.\n",
          "type": "array",
          "items": {
            "$ref": "#/definitions/container_namespace"
          }
        },
        "state": {
          "description": "When read, this contains the current container state. On creation, this requests the initial state (valid options: ` + "`" + `created` + "`" + ` or ` + "`" + `running` + "`" + `). The default is ` + "`" + `created` + "`" + `.\n",
          "$ref": "#/definitions/container_state"
        },
        "systemd": {
          "description": "When ` + "`" + `systemd` + "`" + ` is set to ` + "`" + `true` + "`" + `, we will assume that this container will run ` + "`" + `systemd` + "`" + `, and perform the necessary magic dance to make systemd run inside of the container. The default is ` + "`" + `false` + "`" + `.\n",
          "type": "boolean"
        }
      }
    },
    "container_namespace": {
      "description": "Linux namespace",
      "type": "string",
      "enum": [
        "cgroup",
        "ipc",
        "net",
        "mnt",
        "pid",
        "time",
        "user",
        "uts"
      ]
    },
    "container_state": {
      "description": "Valid container states",
      "type": "string",
      "enum": [
        "created",
        "running",
        "stopping",
        "exited",
        "dead"
      ]
    },
    "error": {
      "type": "object",
      "required": [
        "message"
      ],
      "properties": {
        "code": {
          "type": "integer",
          "format": "int64"
        },
        "message": {
          "type": "string"
        }
      }
    },
    "id": {
      "description": "An ID is a unique numeric ID that references an object.  \nIDs are not necessarily unique across object types.\nIDs are generall readOnly and generated internally.\n",
      "type": "integer",
      "format": "int64"
    },
    "mount": {
      "description": "Generically address mounts by kind and ID or definition\nEither an ` + "`" + `mount_id` + "`" + ` or a mount definition must be supplied.\nIf both are supplied, the mount definition will be ignored.\nIf ` + "`" + `mount_id` + "`" + ` is specified, then the kind/id will be used to reference that mount.\nIf no ` + "`" + `mount_id` + "`" + ` is supplied a defition of type ` + "`" + `kind` + "`" + ` must be present.\n",
      "type": "object",
      "required": [
        "kind"
      ],
      "properties": {
        "kind": {
          "type": "string",
          "enum": [
            "overlay",
            "rbd"
          ]
        },
        "mount_id": {
          "$ref": "#/definitions/id"
        },
        "overlay": {
          "$ref": "#/definitions/mount_overlay"
        },
        "rbd": {
          "$ref": "#/definitions/mount_rbd"
        }
      }
    },
    "mount_overlay": {
      "description": "` + "`" + `mount_overlay` + "`" + ` describes an Overlayfs mount.  All mount points must be RBD ID's.\nAt very least, ` + "`" + `lower` + "`" + ` must be specified.  If ` + "`" + `upper` + "`" + ` length is zero, no ` + "`" + `upper` + "`" + `\nmounts will be used.  ` + "`" + `workdir` + "`" + ` will be assigned automatically.\n\nIf the mounts specified in ` + "`" + `lower` + "`" + ` are specifications and not ID references, they\nwill be recursively mounted/attached.\n\nOverlay mounts are identified by their uppermost ` + "`" + `lower` + "`" + ` ID.\n",
      "type": "object",
      "required": [
        "lower"
      ],
      "properties": {
        "id": {
          "$ref": "#/definitions/id",
          "readOnly": true
        },
        "lower": {
          "description": "This is an array of mount specifications to be used (in order) as lower mounts for the overlay.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/mount"
          }
        },
        "mountpoint": {
          "type": "string",
          "readOnly": true
        },
        "refs": {
          "type": "integer",
          "format": "int64",
          "readOnly": true
        },
        "upperdir": {
          "description": "currently, upperdir is always a directory in mountDir",
          "type": "string",
          "readOnly": true
        },
        "workdir": {
          "type": "string",
          "readOnly": true
        }
      }
    },
    "mount_rbd": {
      "description": "mount_rbd describes an RBD mount.  This must have at least and RBD ID associated with it\n(which becomes the mount's ID), and a provided filesystem type.\n\nEither ` + "`" + `rbd_id` + "`" + ` or ` + "`" + `rbd` + "`" + ` must be specified.  If both are specified, ` + "`" + `rbd` + "`" + ` will be ignored.\n\nIf ` + "`" + `rbd` + "`" + ` is specified and ` + "`" + `rbd_id` + "`" + ` is omitted, the RBD will first be attached, and will be\ndetached on deletion.\n",
      "required": [
        "fs_type"
      ],
      "properties": {
        "fs_type": {
          "type": "string"
        },
        "id": {
          "$ref": "#/definitions/id",
          "readOnly": true
        },
        "mount_options": {
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "mountpoint": {
          "type": "string",
          "readOnly": true
        },
        "rbd": {
          "$ref": "#/definitions/rbd"
        },
        "rbd_id": {
          "$ref": "#/definitions/id"
        },
        "refs": {
          "type": "integer",
          "format": "int64",
          "readOnly": true
        }
      }
    },
    "name": {
      "description": "A name is a unique, user-provided identifier for an object.\n\nA name must consist of numbers, letters, and the symbols in the set { ` + "`" + `.` + "`" + `, ` + "`" + `-` + "`" + `, ` + "`" + `_` + "`" + `}.\n",
      "type": "string",
      "pattern": "^[A-Za-z0-1.-_]*$"
    },
    "rbd": {
      "description": "rbd describes an RBD map.  To successfully map, at least one monitor, pool and image must be specified.\nAdditionally, you will need options.name and options.secret specified.\n",
      "type": "object",
      "required": [
        "monitors",
        "pool",
        "image"
      ],
      "properties": {
        "device_file": {
          "description": "The device_file is the path to the system device file.",
          "type": "string",
          "readOnly": true
        },
        "device_id": {
          "description": "The dev_id is the device ID in the rbd subsystem.",
          "type": "integer",
          "format": "int64",
          "readOnly": true
        },
        "id": {
          "$ref": "#/definitions/id"
        },
        "image": {
          "type": "string",
          "minLength": 1
        },
        "monitors": {
          "type": "array",
          "items": {
            "type": "string",
            "format": "ipv4",
            "pattern": "^(?:[0-9]{1,3}\\.){3}[0-9]{1,3}$"
          }
        },
        "options": {
          "$ref": "#/definitions/rbd_options"
        },
        "pool": {
          "type": "string",
          "minLength": 1
        },
        "refs": {
          "type": "integer",
          "format": "int64",
          "readOnly": true
        },
        "snapshot": {
          "type": "string"
        }
      }
    },
    "rbd_options": {
      "type": "object",
      "properties": {
        "abort_on_full": {
          "type": "boolean"
        },
        "alloc_size": {
          "type": "integer"
        },
        "ceph_requires_signatures": {
          "type": "boolean"
        },
        "cephx_sign_messages": {
          "type": "boolean"
        },
        "crc": {
          "type": "boolean"
        },
        "exclusive": {
          "type": "boolean"
        },
        "force": {
          "type": "boolean"
        },
        "fsid": {
          "type": "string"
        },
        "ip": {
          "type": "string",
          "format": "ipv4",
          "pattern": "^(?:[0-9]{1,3}\\.){3}[0-9]{1,3}$"
        },
        "lock_on_read": {
          "type": "boolean"
        },
        "lock_timeout": {
          "type": "integer",
          "format": "int64"
        },
        "mount_timeout": {
          "type": "integer"
        },
        "name": {
          "type": "string"
        },
        "namespace": {
          "type": "string"
        },
        "noceph_requires_signatures": {
          "type": "boolean"
        },
        "nocephx_sign_messages": {
          "type": "boolean"
        },
        "nocrc": {
          "type": "boolean"
        },
        "noshare": {
          "type": "boolean"
        },
        "notcp_nodelay": {
          "type": "boolean"
        },
        "notrim": {
          "type": "boolean"
        },
        "osd_idle_ttl": {
          "type": "integer"
        },
        "osdkeepalive": {
          "type": "integer"
        },
        "queue_depth": {
          "type": "integer"
        },
        "ro": {
          "type": "boolean"
        },
        "rw": {
          "type": "boolean"
        },
        "secret": {
          "type": "string"
        },
        "share": {
          "type": "boolean"
        },
        "tcp_nodelay": {
          "type": "boolean"
        }
      }
    }
  }
}`))
	FlatSwaggerJSON = json.RawMessage([]byte(`{
  "consumes": [
    "application/json"
  ],
  "produces": [
    "application/json"
  ],
  "schemes": [
    "http",
    "https"
  ],
  "swagger": "2.0",
  "info": {
    "description": "This API specification describes a service for attaching, mounting and preparing container images and manipulating those containers.\n\nIn general, higher level objects can either reference lower level objects (e.g. a mount referencing an attachment point) by a reference ID, \nor, they can contain the full specification of those lower objects.\n\nIf an object references another by ID, deletion of that object does not effect the underlying object.\n\nIf an object defines a lower level object, that lower level object will automatically be deleted on deletion of the higher level object.\n\nFor instance, if a container contains all of the defintions for all mount points and attachments, deletion of the container will automatically unmount\nand detach those lower objects.\n",
    "title": "Image API",
    "version": "1.0.0"
  },
  "basePath": "/imageapi/v1",
  "paths": {
    "/attach/rbd": {
      "get": {
        "tags": [
          "attach"
        ],
        "operationId": "list_rbds",
        "responses": {
          "200": {
            "description": "list of rbd maps",
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/definitions/rbd"
              }
            }
          },
          "default": {
            "description": "generic error response",
            "schema": {
              "$ref": "#/definitions/error"
            }
          }
        }
      },
      "post": {
        "tags": [
          "attach"
        ],
        "operationId": "map_rbd",
        "parameters": [
          {
            "name": "rbd",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/rbd"
            }
          }
        ],
        "responses": {
          "201": {
            "description": "RBD attach succeed",
            "schema": {
              "$ref": "#/definitions/rbd"
            }
          },
          "default": {
            "description": "error",
            "schema": {
              "$ref": "#/definitions/error"
            }
          }
        }
      }
    },
    "/attach/rbd/{id}": {
      "get": {
        "tags": [
          "attach"
        ],
        "operationId": "get_rbd",
        "responses": {
          "200": {
            "description": "RBD entry",
            "schema": {
              "$ref": "#/definitions/rbd"
            }
          },
          "default": {
            "description": "error",
            "schema": {
              "$ref": "#/definitions/error"
            }
          }
        }
      },
      "delete": {
        "tags": [
          "attach"
        ],
        "operationId": "unmap_rbd",
        "responses": {
          "200": {
            "description": "Unmapped",
            "schema": {
              "$ref": "#/definitions/rbd"
            }
          },
          "default": {
            "description": "error",
            "schema": {
              "$ref": "#/definitions/error"
            }
          }
        }
      },
      "parameters": [
        {
          "type": "integer",
          "format": "int64",
          "name": "id",
          "in": "path",
          "required": true
        }
      ]
    },
    "/container": {
      "get": {
        "description": "Get a list of containers",
        "tags": [
          "containers"
        ],
        "operationId": "list_containers",
        "responses": {
          "200": {
            "description": "List of containers",
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/definitions/container"
              }
            }
          },
          "default": {
            "description": "error",
            "schema": {
              "$ref": "#/definitions/error"
            }
          }
        }
      },
      "post": {
        "description": "Create a container",
        "tags": [
          "containers"
        ],
        "operationId": "create_container",
        "parameters": [
          {
            "name": "container",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/container"
            }
          }
        ],
        "responses": {
          "201": {
            "description": "Container creation succeed",
            "schema": {
              "$ref": "#/definitions/container"
            }
          },
          "default": {
            "description": "error",
            "schema": {
              "$ref": "#/definitions/error"
            }
          }
        }
      }
    },
    "/container/byname/{name}": {
      "get": {
        "description": "Get a container definition",
        "tags": [
          "containers"
        ],
        "operationId": "get_container_byname",
        "responses": {
          "200": {
            "description": "Container entry",
            "schema": {
              "$ref": "#/definitions/container"
            }
          },
          "default": {
            "description": "error",
            "schema": {
              "$ref": "#/definitions/error"
            }
          }
        }
      },
      "delete": {
        "description": "Delete a container defition.  \nThis will stop running containers.\n",
        "tags": [
          "containers"
        ],
        "operationId": "delete_container_byname",
        "responses": {
          "200": {
            "description": "Container deleted",
            "schema": {
              "$ref": "#/definitions/container"
            }
          },
          "default": {
            "description": "error",
            "schema": {
              "$ref": "#/definitions/error"
            }
          }
        }
      },
      "parameters": [
        {
          "pattern": "^[a-zA-Z0-9._-]*$",
          "type": "string",
          "name": "name",
          "in": "path",
          "required": true
        }
      ]
    },
    "/container/byname/{name}/{state}": {
      "get": {
        "description": "Request a (valid) state for a container. \nValid states to request include: ` + "`" + `running` + "`" + `, ` + "`" + `exited` + "`" + `, ` + "`" + `paused` + "`" + ` (paused is not yet implemented)\n",
        "tags": [
          "containers"
        ],
        "operationId": "set_container_state_byname",
        "responses": {
          "200": {
            "description": "Container state changed",
            "schema": {
              "$ref": "#/definitions/container"
            }
          },
          "default": {
            "description": "error",
            "schema": {
              "$ref": "#/definitions/error"
            }
          }
        }
      },
      "parameters": [
        {
          "pattern": "^[a-zA-Z0-9._-]*$",
          "type": "string",
          "name": "name",
          "in": "path",
          "required": true
        },
        {
          "enum": [
            "running",
            "exited"
          ],
          "type": "string",
          "name": "state",
          "in": "path",
          "required": true
        }
      ]
    },
    "/container/{id}": {
      "get": {
        "description": "Get a container definition",
        "tags": [
          "containers"
        ],
        "operationId": "get_container",
        "responses": {
          "200": {
            "description": "Container entry",
            "schema": {
              "$ref": "#/definitions/container"
            }
          },
          "default": {
            "description": "error",
            "schema": {
              "$ref": "#/definitions/error"
            }
          }
        }
      },
      "delete": {
        "description": "Delete a container defition.  \nThis will stop running containers.\n",
        "tags": [
          "containers"
        ],
        "operationId": "delete_container",
        "responses": {
          "200": {
            "description": "Container deleted",
            "schema": {
              "$ref": "#/definitions/container"
            }
          },
          "default": {
            "description": "error",
            "schema": {
              "$ref": "#/definitions/error"
            }
          }
        }
      },
      "parameters": [
        {
          "type": "integer",
          "format": "int64",
          "name": "id",
          "in": "path",
          "required": true
        }
      ]
    },
    "/container/{id}/{state}": {
      "get": {
        "description": "Request a (valid) state for a container. \nValid states to request include: ` + "`" + `running` + "`" + `, ` + "`" + `exited` + "`" + `, ` + "`" + `paused` + "`" + ` (paused is not yet implemented)\n",
        "tags": [
          "containers"
        ],
        "operationId": "set_container_state",
        "responses": {
          "200": {
            "description": "Container state changed",
            "schema": {
              "$ref": "#/definitions/container"
            }
          },
          "default": {
            "description": "error",
            "schema": {
              "$ref": "#/definitions/error"
            }
          }
        }
      },
      "parameters": [
        {
          "type": "integer",
          "format": "int64",
          "name": "id",
          "in": "path",
          "required": true
        },
        {
          "enum": [
            "running",
            "exited"
          ],
          "type": "string",
          "name": "state",
          "in": "path",
          "required": true
        }
      ]
    },
    "/mount": {
      "get": {
        "description": "List mounts",
        "tags": [
          "mounts"
        ],
        "operationId": "list_mounts",
        "responses": {
          "200": {
            "description": "list all mounts",
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/definitions/mount"
              }
            }
          },
          "default": {
            "description": "error",
            "schema": {
              "$ref": "#/definitions/error"
            }
          }
        }
      },
      "post": {
        "description": "Create a new mount by mount specification.",
        "tags": [
          "mounts"
        ],
        "operationId": "mount",
        "parameters": [
          {
            "name": "mount",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/mount"
            }
          }
        ],
        "responses": {
          "201": {
            "description": "mount succeed",
            "schema": {
              "$ref": "#/definitions/mount"
            }
          },
          "default": {
            "description": "error",
            "schema": {
              "$ref": "#/definitions/error"
            }
          }
        }
      },
      "delete": {
        "description": "Unmount a specified mount.  Note that mount reference IDs must be specified.",
        "tags": [
          "mounts"
        ],
        "parameters": [
          {
            "name": "mount",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/mount"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Unmount succeeded",
            "schema": {
              "$ref": "#/definitions/mount"
            }
          },
          "default": {
            "description": "Unmount failed",
            "schema": {
              "$ref": "#/definitions/error"
            }
          }
        }
      }
    },
    "/mount/overlay": {
      "get": {
        "tags": [
          "mounts"
        ],
        "operationId": "list_mounts_overlay",
        "responses": {
          "200": {
            "description": "list of overlay mounts",
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/definitions/mount_overlay"
              }
            }
          },
          "default": {
            "description": "error",
            "schema": {
              "$ref": "#/definitions/error"
            }
          }
        }
      },
      "post": {
        "tags": [
          "mounts"
        ],
        "operationId": "mount_overlay",
        "parameters": [
          {
            "name": "mount",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/mount_overlay"
            }
          }
        ],
        "responses": {
          "201": {
            "description": "Overlay mount succeed",
            "schema": {
              "$ref": "#/definitions/mount_overlay"
            }
          },
          "default": {
            "description": "error",
            "schema": {
              "$ref": "#/definitions/error"
            }
          }
        }
      }
    },
    "/mount/overlay/{id}": {
      "get": {
        "tags": [
          "mounts"
        ],
        "operationId": "get_mount_overlay",
        "responses": {
          "200": {
            "description": "Overlay mount entry",
            "schema": {
              "$ref": "#/definitions/mount_overlay"
            }
          },
          "default": {
            "description": "error",
            "schema": {
              "$ref": "#/definitions/error"
            }
          }
        }
      },
      "delete": {
        "tags": [
          "mounts"
        ],
        "operationId": "unmount_overlay",
        "responses": {
          "200": {
            "description": "Unmounted",
            "schema": {
              "$ref": "#/definitions/mount_overlay"
            }
          },
          "default": {
            "description": "error",
            "schema": {
              "$ref": "#/definitions/error"
            }
          }
        }
      },
      "parameters": [
        {
          "type": "integer",
          "format": "int64",
          "name": "id",
          "in": "path",
          "required": true
        }
      ]
    },
    "/mount/rbd": {
      "get": {
        "tags": [
          "mounts"
        ],
        "operationId": "list_mounts_rbd",
        "responses": {
          "200": {
            "description": "list of rbd mounts",
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/definitions/mount_rbd"
              }
            }
          },
          "default": {
            "description": "error",
            "schema": {
              "$ref": "#/definitions/error"
            }
          }
        }
      },
      "post": {
        "tags": [
          "mounts"
        ],
        "operationId": "mount_rbd",
        "parameters": [
          {
            "name": "mount",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/mount_rbd"
            }
          }
        ],
        "responses": {
          "201": {
            "description": "RBD mount succeed",
            "schema": {
              "$ref": "#/definitions/mount_rbd"
            }
          },
          "default": {
            "description": "error",
            "schema": {
              "$ref": "#/definitions/error"
            }
          }
        }
      }
    },
    "/mount/rbd/{id}": {
      "get": {
        "tags": [
          "mounts"
        ],
        "operationId": "get_mount_rbd",
        "responses": {
          "200": {
            "description": "RBD mount entry",
            "schema": {
              "$ref": "#/definitions/mount_rbd"
            }
          },
          "default": {
            "description": "error",
            "schema": {
              "$ref": "#/definitions/error"
            }
          }
        }
      },
      "delete": {
        "tags": [
          "mounts"
        ],
        "operationId": "unmount_rbd",
        "responses": {
          "200": {
            "description": "Unmounted",
            "schema": {
              "$ref": "#/definitions/mount_rbd"
            }
          },
          "default": {
            "description": "error",
            "schema": {
              "$ref": "#/definitions/error"
            }
          }
        }
      },
      "parameters": [
        {
          "type": "integer",
          "format": "int64",
          "name": "id",
          "in": "path",
          "required": true
        }
      ]
    }
  },
  "definitions": {
    "container": {
      "description": "The ` + "`" + `container` + "`" + ` option describes a minimally namespaced container.\n\nA container is identified by a service-provided unique numeric ` + "`" + `pid` + "`" + `.\n\nOptionally, a container can be provided with a ` + "`" + `name` + "`" + `.  The name must\nbe unique.  Containers can be referenced by ` + "`" + `name` + "`" + ` if provided.\n",
      "type": "object",
      "required": [
        "mount",
        "command"
      ],
      "properties": {
        "command": {
          "type": "string"
        },
        "id": {
          "$ref": "#/definitions/id"
        },
        "logfile": {
          "type": "string",
          "readOnly": true
        },
        "mount": {
          "$ref": "#/definitions/mount"
        },
        "name": {
          "description": "name is an optional identifier for the container.  Name must be unique.",
          "$ref": "#/definitions/name"
        },
        "namespaces": {
          "description": "A list of Linux namespaces to use.\n\nNote: This is currently unused.  All containers currently get ` + "`" + `mnt` + "`" + ` and ` + "`" + `pid` + "`" + `.\n      It's here as a placeholder for future use.\n",
          "type": "array",
          "items": {
            "$ref": "#/definitions/container_namespace"
          }
        },
        "state": {
          "description": "When read, this contains the current container state. On creation, this requests the initial state (valid options: ` + "`" + `created` + "`" + ` or ` + "`" + `running` + "`" + `). The default is ` + "`" + `created` + "`" + `.\n",
          "$ref": "#/definitions/container_state"
        },
        "systemd": {
          "description": "When ` + "`" + `systemd` + "`" + ` is set to ` + "`" + `true` + "`" + `, we will assume that this container will run ` + "`" + `systemd` + "`" + `, and perform the necessary magic dance to make systemd run inside of the container. The default is ` + "`" + `false` + "`" + `.\n",
          "type": "boolean"
        }
      }
    },
    "container_namespace": {
      "description": "Linux namespace",
      "type": "string",
      "enum": [
        "cgroup",
        "ipc",
        "net",
        "mnt",
        "pid",
        "time",
        "user",
        "uts"
      ]
    },
    "container_state": {
      "description": "Valid container states",
      "type": "string",
      "enum": [
        "created",
        "running",
        "stopping",
        "exited",
        "dead"
      ]
    },
    "error": {
      "type": "object",
      "required": [
        "message"
      ],
      "properties": {
        "code": {
          "type": "integer",
          "format": "int64"
        },
        "message": {
          "type": "string"
        }
      }
    },
    "id": {
      "description": "An ID is a unique numeric ID that references an object.  \nIDs are not necessarily unique across object types.\nIDs are generall readOnly and generated internally.\n",
      "type": "integer",
      "format": "int64"
    },
    "mount": {
      "description": "Generically address mounts by kind and ID or definition\nEither an ` + "`" + `mount_id` + "`" + ` or a mount definition must be supplied.\nIf both are supplied, the mount definition will be ignored.\nIf ` + "`" + `mount_id` + "`" + ` is specified, then the kind/id will be used to reference that mount.\nIf no ` + "`" + `mount_id` + "`" + ` is supplied a defition of type ` + "`" + `kind` + "`" + ` must be present.\n",
      "type": "object",
      "required": [
        "kind"
      ],
      "properties": {
        "kind": {
          "type": "string",
          "enum": [
            "overlay",
            "rbd"
          ]
        },
        "mount_id": {
          "$ref": "#/definitions/id"
        },
        "overlay": {
          "$ref": "#/definitions/mount_overlay"
        },
        "rbd": {
          "$ref": "#/definitions/mount_rbd"
        }
      }
    },
    "mount_overlay": {
      "description": "` + "`" + `mount_overlay` + "`" + ` describes an Overlayfs mount.  All mount points must be RBD ID's.\nAt very least, ` + "`" + `lower` + "`" + ` must be specified.  If ` + "`" + `upper` + "`" + ` length is zero, no ` + "`" + `upper` + "`" + `\nmounts will be used.  ` + "`" + `workdir` + "`" + ` will be assigned automatically.\n\nIf the mounts specified in ` + "`" + `lower` + "`" + ` are specifications and not ID references, they\nwill be recursively mounted/attached.\n\nOverlay mounts are identified by their uppermost ` + "`" + `lower` + "`" + ` ID.\n",
      "type": "object",
      "required": [
        "lower"
      ],
      "properties": {
        "id": {
          "$ref": "#/definitions/id",
          "readOnly": true
        },
        "lower": {
          "description": "This is an array of mount specifications to be used (in order) as lower mounts for the overlay.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/mount"
          }
        },
        "mountpoint": {
          "type": "string",
          "readOnly": true
        },
        "refs": {
          "type": "integer",
          "format": "int64",
          "readOnly": true
        },
        "upperdir": {
          "description": "currently, upperdir is always a directory in mountDir",
          "type": "string",
          "readOnly": true
        },
        "workdir": {
          "type": "string",
          "readOnly": true
        }
      }
    },
    "mount_rbd": {
      "description": "mount_rbd describes an RBD mount.  This must have at least and RBD ID associated with it\n(which becomes the mount's ID), and a provided filesystem type.\n\nEither ` + "`" + `rbd_id` + "`" + ` or ` + "`" + `rbd` + "`" + ` must be specified.  If both are specified, ` + "`" + `rbd` + "`" + ` will be ignored.\n\nIf ` + "`" + `rbd` + "`" + ` is specified and ` + "`" + `rbd_id` + "`" + ` is omitted, the RBD will first be attached, and will be\ndetached on deletion.\n",
      "required": [
        "fs_type"
      ],
      "properties": {
        "fs_type": {
          "type": "string"
        },
        "id": {
          "$ref": "#/definitions/id",
          "readOnly": true
        },
        "mount_options": {
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "mountpoint": {
          "type": "string",
          "readOnly": true
        },
        "rbd": {
          "$ref": "#/definitions/rbd"
        },
        "rbd_id": {
          "$ref": "#/definitions/id"
        },
        "refs": {
          "type": "integer",
          "format": "int64",
          "readOnly": true
        }
      }
    },
    "name": {
      "description": "A name is a unique, user-provided identifier for an object.\n\nA name must consist of numbers, letters, and the symbols in the set { ` + "`" + `.` + "`" + `, ` + "`" + `-` + "`" + `, ` + "`" + `_` + "`" + `}.\n",
      "type": "string",
      "pattern": "^[A-Za-z0-1.-_]*$"
    },
    "rbd": {
      "description": "rbd describes an RBD map.  To successfully map, at least one monitor, pool and image must be specified.\nAdditionally, you will need options.name and options.secret specified.\n",
      "type": "object",
      "required": [
        "monitors",
        "pool",
        "image"
      ],
      "properties": {
        "device_file": {
          "description": "The device_file is the path to the system device file.",
          "type": "string",
          "readOnly": true
        },
        "device_id": {
          "description": "The dev_id is the device ID in the rbd subsystem.",
          "type": "integer",
          "format": "int64",
          "readOnly": true
        },
        "id": {
          "$ref": "#/definitions/id"
        },
        "image": {
          "type": "string",
          "minLength": 1
        },
        "monitors": {
          "type": "array",
          "items": {
            "type": "string",
            "format": "ipv4",
            "pattern": "^(?:[0-9]{1,3}\\.){3}[0-9]{1,3}$"
          }
        },
        "options": {
          "$ref": "#/definitions/rbd_options"
        },
        "pool": {
          "type": "string",
          "minLength": 1
        },
        "refs": {
          "type": "integer",
          "format": "int64",
          "readOnly": true
        },
        "snapshot": {
          "type": "string"
        }
      }
    },
    "rbd_options": {
      "type": "object",
      "properties": {
        "abort_on_full": {
          "type": "boolean"
        },
        "alloc_size": {
          "type": "integer"
        },
        "ceph_requires_signatures": {
          "type": "boolean"
        },
        "cephx_sign_messages": {
          "type": "boolean"
        },
        "crc": {
          "type": "boolean"
        },
        "exclusive": {
          "type": "boolean"
        },
        "force": {
          "type": "boolean"
        },
        "fsid": {
          "type": "string"
        },
        "ip": {
          "type": "string",
          "format": "ipv4",
          "pattern": "^(?:[0-9]{1,3}\\.){3}[0-9]{1,3}$"
        },
        "lock_on_read": {
          "type": "boolean"
        },
        "lock_timeout": {
          "type": "integer",
          "format": "int64"
        },
        "mount_timeout": {
          "type": "integer"
        },
        "name": {
          "type": "string"
        },
        "namespace": {
          "type": "string"
        },
        "noceph_requires_signatures": {
          "type": "boolean"
        },
        "nocephx_sign_messages": {
          "type": "boolean"
        },
        "nocrc": {
          "type": "boolean"
        },
        "noshare": {
          "type": "boolean"
        },
        "notcp_nodelay": {
          "type": "boolean"
        },
        "notrim": {
          "type": "boolean"
        },
        "osd_idle_ttl": {
          "type": "integer"
        },
        "osdkeepalive": {
          "type": "integer"
        },
        "queue_depth": {
          "type": "integer"
        },
        "ro": {
          "type": "boolean"
        },
        "rw": {
          "type": "boolean"
        },
        "secret": {
          "type": "string"
        },
        "share": {
          "type": "boolean"
        },
        "tcp_nodelay": {
          "type": "boolean"
        }
      }
    }
  }
}`))
}
